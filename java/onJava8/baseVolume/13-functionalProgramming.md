# 函数式编程

OO（Object-oriented，面向对象）是抽象数据，FP（Functional Programming，函数式编程）是抽象行为。

## Lambda 表达式

Lambda 表达式是使用最小可能语法编写的函数定义：

- Lambda 表达式产生函数，而不是类。在 JVM 上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。
- Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。

Lambda 表达式的基本语法是：

- 参数。
- 接着 `->`，可视为“产出”。
- `->` 之后的内容都是方法体。
    - 当只用一个参数，可以不需要括号 ()。
    - 正常情况使用括号 () 包裹参数。为了保持一致性，也可以使用括号 () 包裹单个参数，虽然这种情况并不常见。
    - 如果没有参数，则必须使用括号 () 表示空参数列表。
    - 对于多个参数，将参数列表放在括号 () 中。

到目前为止，所有 Lambda 表达式方法体都是单行。该表达式的结果自动成为 Lambda 表达式的返回值，在此处使用 return 关键字是非法的。

如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。在这种情况下，就需要使用 return。

## 函数式接口

- `java.util.function` 包包含一组接口，这些接口是 Lambda 表达式和方法引用的目标类型。每个接口只包含一个抽象方法，称为函数式方法。
- 如果将方法引用或 Lambda 表达式赋值给函数式接口（类型需要匹配），Java 会适配你的赋值到目标接口。编译器会自动包装方法引用或 Lambda 表达式到实现目标接口的类的实例中。

基本命名准则：

- 如果只处理对象而非基本类型，名称则为 `Function`，`Consumer`，`Predicate` 等。参数类型通过泛型添加。
- 如果接收的参数是基本类型，则由名称的第一部分表示，如 `LongConsumer`，`DoubleFunction`，`IntPredicate` 等，但基本 `Supplier` 类型例外。
- 如果返回值为基本类型，则用 `To` 表示，如 `ToLongFunction <T>` 和 `IntToLongFunction。`
- 如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 `UnaryOperator`，两个参数使用 `BinaryOperator`。
- 如果接收两个参数且返回值为布尔值，则是一个谓词（`Predicate`）。
- 如果接收的两个参数类型不同，则名称中有一个 `Bi`。

### 多参数函数式接口

```java
@FunctionalInterface
public interface TriFunction<T, U, V, R> {
    R apply(T t, U u, V v);
}
```

### 缺少基本类型的函数

`System.out.format()` 类似于 `System.out.println()` 但提供了更多的显示选项。这里，`%f` 表示将 n 作为浮点值给出，`%d` 表示 n 是一个整数值。这其中可以包含空格，输入 `%n` 会换行 — 当然使用传统的 `\n` 也能换行，但 `%n` 是自动跨平台的。

## 高阶函数

高阶函数（Higher-order Function）只是一个消费或产生函数的函数。

- 使用继承，可以轻松地为专用接口创建别名。
- 使用 Lambda 表达式，可以轻松地在方法中创建和返回一个函数。

## 闭包

- 被 Lambda 表达式引用的局部变量必须是 `final` 或者是等同 `final` 效果的。
- 等同 `final` 效果（Effectively Final）表示虽然没有明确地声明变量是 `final` 的，但是因变量值没被改变过而实际有了 `final` 同等的效果。如果局部变量的初始值永远不会改变，那么它实际上就是 `final` 的。
- 等同 `final` 效果意味着可以在变量声明前加上 `final` 关键字而不用更改任何其余代码。实际上它就是具备 `final` 效果的，只是没有明确说明。
- 应用于对象引用的 `final` 关键字仅表示不会重新赋值引用。它并不代表你不能修改对象本身。

## 柯里化和部分求值

柯里化意为将一个多参数的函数，转换为一系列单参数函数。
