# 什么是对象

## 抽象

对象具有状态、行为和标识。这意味着对象有自己的内部数据（提供状态）、方法 (产生行为)，并彼此区分（每个对象在内存中都有唯一的地址）。

## 接口

[UML](https://en.wikipedia.org/wiki/Unified_Modeling_Language)

```text
+------------------+
|   User           |
+------------------+
| - id: int        |
| - name: string   |
+------------------+
| + login(): bool  |
| + logout(): void |
+------------------+
```

## 封装

Java 有三个显式关键字来设置类中的访问权限：`public`、`private` 和 `protected`。这些访问修饰符决定了谁能使用它们修饰的方法、变量或类：

- `public`：表示任何人都可以访问和使用该元素；
- `private`：除了类本身和类内部的方法，外界无法直接访问该元素。`private` 是类和调用者之间的屏障，任何试图访问私有成员的行为都会报编译时错误。
- `protected`：类似于 `private`，区别是子类可以访问 `protected` 的成员，但不能访问 `private` 成员。
- `default`：如果你不使用前面的三者，默认就是 `default` 访问权限。`default` 被称为包访问，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问。

## 多态

后期绑定：当向对象发送信息时，被调用的代码直到运行时才确定。编译器确保方法存在，并对参数和返回值执行类型检查，但是它不知道要执行的确切代码。

## 单继承结构

单继承的结构使得垃圾收集器的实现更为容易，这是 Java 在 C++ 基础上的根本改进之一。

## 集合

之所以选择集合有以下两个原因：

- 集合可以提供不同类型的接口和外部行为。
- 不同的集合对某些操作有不同的效率。例如，`List` 的两种基本类型：`ArrayList` 和 `LinkedList`。虽然两者具有相同接口和外部行为，但是在某些操作中它们的效率差别很大。在 `ArrayList` 中随机查找元素是很高效的，而 `LinkedList` 随机查找效率低下。反之，在 `LinkedList` 中插入元素的效率要比在 `ArrayList` 中高。由于底层数据结构的不同，每种集合类型在执行相同的操作时会表现出效率上的差异。

## 对象创建与生命周期

Java 的垃圾收集器被设计用来解决内存释放的问题（虽然这不包括对象清理的其他方面）。垃圾收集器知道对象什么时候不再被使用并且自动释放内存。结合单继承和仅可在堆中创建对象的机制，Java 的编码过程比用 C++ 要简单得多。

## 异常处理

- 异常处理机制将程序错误直接交给编程语言甚至是操作系统。
- 异常处理并不是面向对象的特性。尽管在面向对象的语言中异常通常由对象表示，但是在面向对象语言之前也存在异常处理。
